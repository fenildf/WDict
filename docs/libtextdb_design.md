# 文本数据库设计

## 数据库格式

数据库为纯文本文件。

一般地，每行为一条记录，每个记录有许多数据项。

特殊情况下，数据项中可能包含换行，不过这是不被建议的。

最开始的一项叫做第一项，是*唯一的*键。

例如：

```
keya, value1, value2
"keyb", "value1", "value, 2"
```

其中，`keya`、`keyb`为键，引号为了转义`,`等字符。

## 数据库实现

为了实现数据库，首先是对文件的操作以及对字符串的处理。

C++库不能够很好的满足我们的需求，为此，我们设计了`FileUtils`以及`StringUtils`静态类，提供相应的实用的静态成员函数为补充。

### 文件操作实用程序

`FileUtils`类有如下静态成员函数：

- `ReadAllText` 从`std::istream`中读取全部文本，保存在`std::string`中。
- `Exists` 检测一个文件是否存在。

### 字符串实用程序

`StringUtils`类有如下静态成员函数：

- `Escape` 对一个字符串进行转义操作使其能够直接写入作为数据库的文本文件，并在读取的时候不发生错误。
- `Unescape` 对从数据库获得的一串字符串进行解析，使得程序能够正确处理。

以及函数模板：

- `FromString<T>` 解析字符串为`T`类型的对象。
- `ToString<T>` 将`T`类型的对象转换为字符串。

### 数据库文件解析

有了实用程序作为辅助，就可以实现解析、保存文本数据库的操作了。

为了正确地、灵活地解析上述格式的文本数据库，我们实现了一个词法分析器`Lexer`，输入一串字符串（这里为文本数据库中全部内容），输出token流。

每一个token的信息存放在`Token`类中。

特别地，`SyntaxError`存放了`Lexer`产生的异常。

### 数据库序列化

保存文本数据库较为简单，只需要将字符串进行转义，然后直接写入文件中即可。

### 数据库具体接口

我们实现了一个`TextDB`为基础的数据库类，项目中所有数据库的操作都可以使用此类（当然，也可以使用相同接口的其他实现）。

此类的使用方法与`std::map<std::string, std::vector<std::string> >`完全类似，只不过在构造的时候需要提供一个`std::string`作为数据库路径。事实上，`TextDB`就是`std::map<std::string, std::vector<std::string> >`的一个**代理**。

另外，`TextDB`提供了`Sync`成员函数，每次修改完值之后可以调用此函数来将所有数据持久化。同时，为方便使用和保证数据安全，`TextDB`对象默认会在析构的时候自动调用`Sync`。此外，`TextDB`在构造的时候还接受一个`bool`参数在数据库路径后面，以指示是否以只读的方式访问，这样可以减少磁盘写入并防止数据被意外修改。

然而，`TextDB`的实现是将数据库所有内容全部读入内存后再处理，处理后再统一写入存储器，因此它在处理大数据库的情况下表现不尽如人意。

显然，`TextDB`及相关部件的实现和字典程序完全没有关系，因此它们可以很随意的在另外的项目中复用。

