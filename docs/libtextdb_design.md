# 文本数据库设计

数据库格式见`db_format.md`。

为了实现数据库, 首先是对文件的操作以及对字符串的处理。

C++库不能够很好的满足我们的需求, 为此, 我们设计了`FileUtils`以及`StringUtils`类, 提供相应的实用的静态函数为补充。

`FileUtils`类有如下静态成员函数:

- `ReadAllText` 从`std::istream`中读取全部文本, 保存在`std::string`中。
- `Exists` 检测一个文件是否存在。

`StringUtils`类有如下静态成员函数:

- `Escape` 对一个字符串进行转义操作使其能够直接写入作为数据库的文本文件, 并在读取的时候不发生错误。
- `Unescape` 对从数据库获得的一串字符串进行反转义, 使得程序能够正确处理。

有了这些工具作为辅助, 就可以实现解析、保存文本数据库的操作了。

为了正确地、灵活地解析上述格式的文本数据库, 我们实现了一个词法分析器`Lexer`, 输入一串字符串(这里为文本数据库中全部内容), 输出token流。

token的信息存放在`Token`类中。

特别地, `SyntaxError`存放了`Lexer`产生的异常。

保存文本数据库较为简单, 只需要将字符串进行转义, 然后直接写入文件中即可。

于是, 我们实现了一个`TextDB`为基础的数据库类, 其余所有数据库的操作都依赖此类。

此类的使用方法与`std::map<std::string, std::vector<std::string> >`完全类似, 只不过在构造的时候需要提供一个`std::string`作为数据库路径。事实上, `TextDB`就是`std::map<std::string, std::vector<std::string> >`的一个**Proxy**。

另外, `TextDB`提供了`Sync`成员函数, 每次修改完值之后可以调用此函数来将所有数据持久化。同时, 为方便使用和保证数据安全, `TextDB`对象默认会在析构的时候调用`Sync`。


然而, `TextDB`的实现是将数据库所有内容全部读入内存后再处理, 因此它在处理大数据的情况下表现不尽如人意。

`TextDB`及其依赖的实现和字典程序完全没有关系, 因此它们可以很随意的在另外的项目中复用。